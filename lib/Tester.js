var util = require('util')
var crypto = require('crypto')
var EventEmitter = require('events').EventEmitter

// CHILD Testers MUST:
// * NOT emit an error (instead, self.state.fail with the error)
// * NOT throw an exception, under any circumstances
// * Have a timeout, significantly less than the interval if applicable
// * Assert any bad programmatic input. Operation errors must not be checked via assertion!

// TODO: auto set icon based on pass/fail (check/times) if not defined?


// Represents the state of an entity. Can be serialised, so that client can
// render and reference by a UID. Patches can be emitted to keep server/client
// states/views in sync.
var State = function(initial) {
	if (!(this instanceof State)) return new State()
	EventEmitter.call(this)

	if (!arguments[0])
		initial = {}

	console.assert(initial.entity,   'Tester State: entity must be defined')
	console.assert(initial.name,     'Tester State: name must be defined')
	console.assert(initial.category, 'Tester State: category must be defined')

	// Reference object in method context
	var self = this

	var consecutive_failures = 0
	var consecutive_passes   = 0

	// default, for edge detection + filter
	this.threshold = 3

	var healthy_filtered = null

	// static stuff
	for (var i in initial)
		this[i] = initial[i]

	// DOM ID safe
	// TODO: evaluate using category-name
	var generate_id = function() {
		var hash = crypto.createHash('sha1')
		hash.update(initial.name+initial.category)
		return hash.digest('hex')
	}

	this.id = generate_id()

	// null/false/true, via test
	// undefined is better, as null serialises to false
	this.healthy = undefined

	// don't do this, access attributes directly
	//this.get = function(key) { }

	this.set = function(key,val) {
		if (self[key] == val && key != 'healthy') return
		self[key] = val
		self.emit('set',key,val)
	}

	this.append = function(key,val) {
		if (!val) return
		self[key].append(val)
		self.emit('append',self.id,key,val)
	}

	this.fail = function(err) {
		// patch a remote state
		self.set('healthy',false)

		consecutive_failures++
		consecutive_passes = 0

		// error object, probably with err.message
		if (typeof err == 'object') {
			if (err.message)
				self.set('error',err.message)
			else
				self.set('error',err.toString())
		} else if (arguments[0])
			self.set('error',err)

		if (consecutive_failures == 1)
			self.lastfailedge = new Date()

		if (consecutive_failures == self.threshold) {
			// real failure after a real pass
			if (healthy_filtered == 1) pushEvent()
			healthy_filtered = 0
		}

	}

	this.pass = function() {
		// patch a remote state
		self.set('healthy',true)

		consecutive_passes++
		consecutive_failures = 0

		if (consecutive_passes == 1)
			self.lastpassedge = new Date()

		if (consecutive_passes == self.threshold) {
			// real failure after a real pass
			if (healthy_filtered == 0) pushEvent()
			healthy_filtered = 1
		}

	}

	var pushEvent = function() {
		// frozen-in-time clone
		var snapshot = JSON.parse(JSON.stringify(self))
		// STRUCTURED LOG EVENT
		//
		// Events are distinct from a state update and are suitable to record in a log
		// or push notification events happen when something has broken or fixed
		// (defined as n consecutive failures or passes)
		// Events are backdated to when the first fail/pass happened in the series.
		//
		// Format: dict/hash of key:vals
		// Must contain 'class' which defines the programatic type of event
		// Must contain 'message' which describes to a human what happened to what
		// Must contain 'date' which is a ISO8601 date (ends with Z) of
		// when the event happened, not when the event was posted.
		// Can contain any other key:val associated to the 'class'. For
		// example, any associated data such as username.
		//
		// If the event contains sensitive/excessive info, everything but the
		// date, class and message can be stripped to display a log.
		//
		// Severity/level is associated with the class, and is
		// application specific. If the log event is to be used in
		// global context, it must be associated with a 'level' of
		// RFC5424. This can be achieved with a simple mapping of class
		// to level.
		//
		// Example classes: fixed, broken, heartbeat, boot, halt
		//
		// The events can be distributed by push publishers, eg Amazon SNS, DSPA.
		e = {
			date : snapshot.healthy? snapshot.lastpassedge : snapshot.lastfailedge,
			name : snapshot.name,
			message : snapshot.healthy? 'System healthy' : snapshot.error,
			category : snapshot.category,
			class : snapshot.healthy? 'fixed':'broken',
			tester_id : self.id,
		}
		self.emit('event',e)
	}

	// I don't want these attributes (from eventemitter) when serialising.
	// I hope this won't break anything. It does not appear to.
	delete this._maxListeners
	delete this.domain
	//delete this._events (_events comes back like a zombie)
}

// Inheritance
util.inherits(State, EventEmitter)

// base class for an entity (may be generated by an enumerator)
// defines interface to tests, attributes etc
var Tester = function(config) {
	if (!(this instanceof Tester)) return new Tester()

	// parent constructor
	EventEmitter.call(this)

	// reference instance in method context
	var self = this

	this.state = new State(config)
	this.id = this.state.id

	// css class/controller
	// default -- simple or base testers will have similar class names
	// config should specify entity, which should choose class
	// Best to set it explicitly anyway
	this.state.class = this.state.entity

	// instance of a test module, for example, HTTP status, ping, mail, DNS
	// must just cause state changes. Can change stat of .error
	// no parameters or callback required, even on error. Update the state instead.
	this.test = function(){}

	// default kind-of-sensible polling interval
	this.interval = 30
	this.timeout  = this.interval/2

	// enumerator/rpc
	//this.update

	// setInterval number
	this.timer = null

	// number of checks this tester makes
	this.assertions = 0
}

// Inheritance
util.inherits(Tester, EventEmitter)
// Exposure
module.exports = Tester


// test
//var foo = new Tester({class:'bar',name:'john',category:'beans'})
//
//
// SEPARATE ENTITY AND STATE TBC
