var util = require('util')
var crypto = require('crypto')
var EventEmitter = require('events').EventEmitter

// CHILD Testers MUST:
// * NOT emit an error (instead, self.state.fail with the error)
// * NOT throw an exception, under any circumstances
// * Have a timeout, significantly less than the interval if applicable
// * Assert any bad programmatic input. Operation errors must not be checked via assertion!

// TODO: auto set icon based on pass/fail (check/times) if not defined?

// Represents the state of an entity. Can be serialised, so that client can
// render and reference by a UID. Patches can be emitted to keep server/client
// states/views in sync.
var State = function(initial) {
	if (!(this instanceof State)) return new State()
	EventEmitter.call(this)

	if (!arguments[0])
		initial = {}

	console.assert(initial.entity,   'Tester State: entity must be defined')
	console.assert(initial.name,     'Tester State: name must be defined')
	console.assert(initial.category, 'Tester State: category must be defined')

	// Reference object in method context
	var self = this

	// static stuff
	for (var i in initial)
		this[i] = initial[i]

	// DOM ID safe
	// TODO: evaluate using category-name
	var generate_id = function() {
		var hash = crypto.createHash('sha1')
		hash.update(initial.name+initial.category)
		return hash.digest('hex')
	}

	this.id = generate_id()

	// null/false/true, via test
	// undefined is better, as null serialises to false
	this.healthy = undefined

	// don't do this, access attributes directly
	//this.get = function(key) { }

	this.set = function(key,val) {
		if (self[key] == val && key != 'healthy') return
		self[key] = val
		self.emit('set',key,val)
	}

	this.append = function(key,val) {
		if (!val) return
		self[key].append(val)
		self.emit('append',self.id,key,val)
	}

	this.fail = function(err) {
		// patch a remote state
		self.set('healthy',false)

		// pattern detection
		sample(0)

		// error object, probably with err.message
		if (typeof err == 'object') {
			if (err.message)
				self.set('error',err.message)
			else
				self.set('error',err.toString())
		} else if (arguments[0])
			self.set('error',err)
	}

	this.pass = function() {
		// patch a remote state
		self.set('healthy',true)

		// pattern detection
		sample(1)
	}

	// pass:1 fail:0. Look for patterns. Length: 3
	var edges = [null,null,null]

	var sample = function(direction) {
		edges.push(direction?1:0)
		edges.shift()

		// frozen-in-time clone
		var event = JSON.parse(JSON.stringify(self))
		event.data = new Date()

		// fail edge, ignoring glitches
		if (edges.toString() == [1,0,0].toString())
			self.emit('failedge',event)

		// not as useful, but here for completeness
		if (edges.toString() == [0,1,1].toString())
			self.emit('passedge',event)

		// not as useful, but here for completeness
		if (edges.toString() == [1,0,1].toString())
			self.emit('glitch',event)
	}

	// I don't want these attributes (from eventemitter) when serialising.
	// I hope this won't break anything. It does not appear to.
	delete this._maxListeners
	delete this.domain
	//delete this._events (_events comes back like a zombie)
}

// Inheritance
util.inherits(State, EventEmitter)

// base class for an entity (may be generated by an enumerator)
// defines interface to tests, attributes etc
var Tester = function(config) {
	if (!(this instanceof Tester)) return new Tester()

	// parent constructor
	EventEmitter.call(this)

	// reference instance in method context
	var self = this

	this.state = new State(config)
	this.id = this.state.id

	// css class/controller
	// default -- simple or base testers will have similar class names
	// config should specify entity, which should choose class
	// Best to set it explicitly anyway
	this.state.class = this.state.entity

	// instance of a test module, for example, HTTP status, ping, mail, DNS
	// must just cause state changes. Can change stat of .error
	// no parameters or callback required, even on error. Update the state instead.
	this.test = function(){}

	// default kind-of-sensible polling interval
	this.interval = 30
	this.timeout  = this.interval/2

	// enumerator/rpc
	//this.update

	// setInterval number
	this.timer = null

	// number of checks this tester makes
	this.assertions = 0
}

// Inheritance
util.inherits(Tester, EventEmitter)
// Exposure
module.exports = Tester


// test
//var foo = new Tester({class:'bar',name:'john',category:'beans'})
//
//
// SEPARATE ENTITY AND STATE TBC
